# 遇到的神奇的错误
- one 

ajax请求：
参数设置为null，结果还是传递过去了。
很神奇的事，在开发环境才发生，但是在生产环境里不会。

如：order:null

然后这里在axios里，统一处理了
一开始忘了get的时候有时候是没有参数的，
就是调用`Object.keys(obj).map(item=>{});`
会提示说类型转换错误，
因为没有参数的时候是undefined。

-----------------------

- two 

axios遇到了请求错误，就是请求还是200，但是有错误，
然后不想分别处理这些错误，就直接throw了一个error，
axios里写了catch，
捕获了这个错误之后，就显示一些message，
然后，reject了这个错误。


好神奇的事，是这个错误在开发环境会再console里发生，但是在生产环境里没发生。

---------

不过有一个前提：
代码不太一致了。
生产环境里的是旧的代码，而且用了代码压缩，没法分辨源代码是怎么写的。
这点就很烦了。。。


的确发生了两次请求，
第一次有错误的请求是有及时更新原来的state的，
但是在连续接着的第二次错误请求并没有更新state了。

所以连错误都没有继续抛出了。。。

找到原因了，

是因为antd的解决不会同时出现两个message的问题。
然后加了个once的判断，默认是false，

这里的错误是指服务端返回200之后可能出现的参数错误之类的。

once是作为全局变量存在。

当第一次发生错误时，once是false，则会执行throw 操作。
当第二次发生时，则once变成了true，则不会再次throw了

不过不是连续点击的时候是还是会继续throw的。
这点很神奇。

throw 之后，catch就会捕获到错误。
然后将once改成了false


结论：
那就是说在抛出错误之后还没来得及执行after就开始执行下一个axios了。
执行下一个axios的时候once还是true，
所以不会执行throw的操作。。。。

所以dva处理那边就将这个请求当做是没有完成的请求，
因为没有接受也没有拒绝。。


但是once应该是全局变量呀，修改了之后还是会修改到once的。





```javascript
 default:
        let { message: msg, error } = res.data;

        for (let val in error) {
            msg = val ? error[val][0] : msg;
        }

        if (!once) {
            // message.error(msg, 2, after);
            once = true;
           throw new Error(msg);
        }
}

```

```javascript

 .catch(error => {
                message.error(error.message, 2, after);
                reject(error);
            });

```





------------------------

- three 

又遇见了一个神奇的问题。
一个菜单，是有二级菜单的，
然后一级的时候是不需要跳转的，只需要点击的时候就直接展开二级菜单，
当在某些二级菜单的时候，点击它的一级菜单不会展开了，因为一级菜单里写了href，所以就跳到这个链接里去了
但是查看了代码，并没有什么特别的，
就给这个一级才到菜单的a绑定了click事件，然后点击的时候，就检查下next是否有sub-menu，有的话，就将全部的open class 移除了，再添加到当前的这个里边来。
按逻辑没有任何问题。



而且是只有到了用户列表页才会发生这件事，其他的菜单都这样了。
但是查看了这个文件夹，也并没有写特殊处理的东西。


终于知道了。。。
通用的app.js返回的是一个对象，
绑定的函数是在里边的一个init里执行的，
但是app.js并没有执行，而是每个页面需要执行一次`App.init();`




-----------------

- four

用antd的message组件，为了让message在同一时间只出现一次，在fetch里加了个判断，
上边第二点有提到的。

这个判断在catch里，判断这个once，是否为false。然后有点尬的是，当你重复点击的时候（这个点击是制造错误），message不会出现了。
就是说第一次出现的message里的after函数没有执行。。

但是在其他地方测试，是会这个after的。
一样都是这么执行request函数。

还有就是没有使用saga来处理的请求，他对request返回的reject不会处理，还会继续执行接下去的代码。

用了saga来请求的然后就退出了当前的代码块了。（是不是这里边已经return了？？？？

这里的唯一区别就是这个。。。不过按道理是不会影响的，因为callback函数应该会在栈里边，然后通过事件emit。。。。。。

好神奇，得看看当前js环境的栈是怎么样的。

为啥一直没有执行这块。(其实是有执行的。因为当你在它消失之后（就是触发onClose事件），它是有执行after函数。

但是不知道为啥一直狂点的时候，它的after函数就被🐶吃了，不知道跑哪里去了。。一个都不会执行。。。
还是得继续找找原因。









